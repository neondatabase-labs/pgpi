#!/usr/bin/env ruby

# Copyright 2025 Databricks, Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

require "optparse"
require "openssl"
require "securerandom" # for cert generation
require "net/imap" # for SASL/SCRAM auth
require "digest" # for MD5 auth

SCRIPT_NAME = "pgpi -- Postgres Private Investigator" # note: name must be valid as a certificate CN
SCRIPT_INFO = "https://github.com/neondatabase-labs/pgpi ++ Copyright 2025 Databricks, Inc. ++ License: Apache 2.0"

options = { # set defaults
  target: nil,
  delete_host_suffix: ".local.neon.build",
  listen_port: 5432,
  connect_port: 5432,
  ssl_negotiation: "mimic",
  sslmode: 'prefer',
  sslrootcert: nil,
  force_password: false,
  redact_passwords: false,
  send_chunks: "whole",
  ssl_cert: nil,
  ssl_key: nil,
  cert_sig: "rsa",
  deny_ssl: false,
  log_certs: false,
  log_proxied: "annotated",
  client_sslkeylogfile: nil,
  server_sslkeylogfile: nil,
  bw: nil,
  quit_on_hangup: false,
  channel_binding: true,
}

OptionParser.new do |opts|
  opts.banner = "#{SCRIPT_NAME}\n#{SCRIPT_INFO}\n\nUsage: pgpi [options]"
  opts.on("--fixed-host a.bc.de",
          "Use a fixed Postgres server hostname (default: via SNI, or 'localhost')") { |v| options[:target] = v }
  opts.on("--delete-host-suffix bc.de",
          "Delete a suffix from server hostname provided by client (default: #{options[:delete_host_suffix]})") { |v| options[:delete_host_suffix] = v }
  opts.on("--listen-port nnnn", /\d{1,5}/,
          "Port on which to listen for client connection (default: #{options[:listen_port]})") { |v| options[:listen_port] = v.to_i }
  opts.on("--connect-port nnnn", /\d{1,5}/,
          "Port on which to connect to server (default: #{options[:connect_port]})") { |v| options[:connect_port] = v.to_i }
  opts.on("--sslmode disabled|prefer|require|verify-ca|verify-full", ['disabled', 'prefer', 'require', 'verify-ca', 'verify-full'],
          "SSL mode for connection to server (default: #{options[:sslmode]})") { |v| options[:sslmode] = v }
  opts.on("--sslrootcert system|/path/to/cert",
          "Root/CA certificate for connection to server (default: #{options[:sslrootcert] || 'none'})") { |v| options[:sslrootcert] = v }
  opts.on("--ssl-negotiation mimic|direct|postgres",
          "SSL negotiation style: mimic client, direct or traditional Postgres (default: #{options[:ssl_negotiation]})") { |v| options[:ssl_negotiation] = v }
  opts.on("--[no-]override-auth",
          "Require password auth from client, do SASL/MD5/password auth with server (default: #{options[:force_password]})") { |v| options[:force_password] = v }
  opts.on("--[no-]channel-binding",
          "Enable channel binding for SASL connection to server with --override-auth (default: #{options[:channel_binding]})") { |v| options[:channel_binding] = v }
  opts.on("--[no-]redact-passwords",
          "Redact password messages in logs (default: #{options[:redact_passwords]})") { |v| options[:redact_passwords] = v }
  opts.on("--send-chunking whole|byte", ["whole", "byte"],
          "Chunk size for sending Postgres data (default: #{options[:send_chunks]})") { |v| options[:send_chunks] = v }
  opts.on("--ssl-cert /path/to/cert",
          "TLS certificate for connection with client (default: generated, self-signed)") { |v| options[:ssl_cert] = v }
  opts.on("--ssl-key /path/to/key",
          "TLS key for connection with client (default: generated)") { |v| options[:ssl_key] = v }
  opts.on("--cert-sig rsa|ecdsa", ["rsa", "ecdsa"],
          "Specify RSA or ECDSA signature for generated certificate (default: #{options[:cert_sig]})") { |v| options[:cert_sig] = v}
  opts.on("--[no-]deny-client-ssl",
          "Tell client that SSL is not supported (default: #{options[:deny_ssl]})") { |v| options[:deny_ssl] = v }
  opts.on("--[no-]log-certs",
          "Log TLS certificates (default: #{options[:log_certs]})") { |v| options[:log_certs] = v }
  opts.on("--log-forwarded none|raw|annotated", ["none", "raw", "annotated"],
          "Whether and how to log forwarded traffic (default: #{options[:log_proxied]})") { |v| options[:log_proxied] = v }
  opts.on("--[no-]quit-on-hangup",
          "Quit when client or server disconnects, instead of looping (default: #{options[:quit_on_hangup]})") { |v| options[:quit_on_hangup] = v }
  opts.on("--client-sslkeylogfile /path/to/log",
          "Where to append client traffic TLS decryption data (default: nowhere)") { |v| options[:client_sslkeylogfile] = v }
  opts.on("--server-sslkeylogfile /path/to/log",
          "Where to append server traffic TLS decryption data (default: nowhere)") { |v| options[:server_sslkeylogfile] = v }
  opts.on("--[no-]bw", "Force monochrome output even to TTY (default: auto)") { |v| options[:bw] = v }
end.parse!

options[:sslmode] = 'verify-full' if options[:sslrootcert] == 'system'  # matches libpq behaviour

ANNOTATE = options[:log_proxied] == "annotated"
REDACT = options[:redact_passwords]
BYTE_WRITE = options[:send_chunks] == "byte"
COLOURFUL = options[:bw].nil? ? STDOUT.tty? : !options[:bw]

# Ruby stdlib compatibility checks

has_sasl = Net::IMAP.const_defined?(:SASL) && Net::IMAP::SASL.const_defined?(:ScramSHA256Authenticator)
if options[:force_password] && !has_sasl
  puts "Missing Net::IMAP::SASL::ScramSHA256Authenticator, so --override-auth will not support SCRAM. Please use Ruby 3.3 or higher."
  # we'll exit later if SCRAM is requested by server
end

if options[:cert_sig] == "ecdsa" && !OpenSSL::PKey::EC.method_defined?(:public_to_pem)
  puts "Missing OpenSSL::PKey::EC#public_to_pem, so --cert-sig ecdsa is not supported. Please use Ruby 3.1 or higher."
  exit 1
end

# misc utils

def bin_str(str) str.force_encoding("ASCII-8BIT") end
def hex_inspect(bytes) '"' + bytes.unpack1("H*").scan(/../).map { |x| "\\x#{x}" }.join + '"' end
def t_now() Process.clock_gettime(Process::CLOCK_MONOTONIC) end
def tls_summary(sock) "#{sock.ssl_version}/#{sock.cipher.first}" end

# colour

module Colour
  S2C = "35"
  C2S = "36"
  NOTE = "33"
end

def colour(c, s) COLOURFUL ? "\033[#{c}m#{s}\033[0m": s end
def annotate(*args)
  args.each_slice(2)
      .map { |s, annot| " #{s}#{ANNOTATE ? colour(Colour::NOTE, " = #{annot}") : ""}" }
      .join
end

def server_to_client(s) "#{colour(Colour::S2C, "server -> client:")}#{s}" end
def server_to_script(s) "#{colour(Colour::S2C, "server -> script:")}#{s}" end
def script_to_client(s) "#{colour(Colour::S2C, "script -> client:")}#{s}" end
def client_to_server(s) "#{colour(Colour::C2S, "client -> server:")}#{s}" end
def client_to_script(s) "#{colour(Colour::C2S, "client -> script:")}#{s}" end
def script_to_server(s) "#{colour(Colour::C2S, "script -> server:")}#{s}" end

# Postgres message parsing/annotation

class PgMessage
  def initialize(msg, source)
    @msg = msg
    @source = source # :server, :client, :startup or nil
    @i = 0
  end

  def line_break() "\n " end
  def text_or_binary(v) v == 0 ? "text" : v == 1 ? "binary" : "unknown" end

  # methods to read from @msg: each returns [value, representation]

  def int8
    byte = @msg[@i...@i += 1]
    [byte.unpack1("C"), hex_inspect(byte)]
  end

  def int16
    bytes = @msg[@i...@i += 2]
    [bytes.unpack1("s>"), hex_inspect(bytes)]
  end

  def int32
    bytes = @msg[@i...@i += 4]
    [bytes.unpack1("l>"), hex_inspect(bytes)]
  end

  def cstr
    value = @msg[@i..].unpack1("Z*")
    bytes = @msg[@i...@i += value.length + 1] # +1 for the null terminator
    [value, bytes.inspect]
  end

  def str(len)
    bytes = @msg[@i...@i += len]
    [bytes, bytes.inspect]
  end

  def bytes(len)
    bytes = @msg[@i...@i += len]
    [bytes, hex_inspect(bytes)]
  end

  def char
    str(1)
  end

  # annotation

  def inspect
    unless ANNOTATE
      return " " + (REDACT && @msg[0] == "p" ? "[password message redacted]" : @msg.inspect)
    end

    s = ""
    if @source == :startup
      lenv, lenr, versionv, versionr = int32 + int32
      puts "unexpected postgres protocol version: #{versionr}" unless versionv == 0x00030000
      s += annotate(lenr, "#{lenv} bytes of startup message", versionr, "protocol version")
      loop do
        keyv, keyr, = cstr
        if keyv.empty?
          s += line_break + annotate(keyr, "end")
          break
        end
        _, valuer = cstr
        s += line_break + annotate(keyr, "key", valuer, "value")
      end

    else
      type_value, type_repr = char
      lenv, lenr = int32

      type_name = if @source == :server
        case type_value # server messages
        when "1"; "ParseComplete"
        when "2"; "BindComplete"
        when "3"; "CloseComplete"

        when "A"
          _, pidr = int32
          _, channelr = cstr
          _, payloadr = cstr
          s += annotate(pidr, "process ID", channelr, "channel name", payloadr, "payload")
          "NotificationResponse"

        when "C"
          _, tagr = cstr
          s += annotate(tagr, "command tag")
          "CommandComplete"

        when "D"
          colcountv, colcountr = int16
          s += annotate(colcountr, "#{colcountv} columns follow")
          colcountv.times do
            s += line_break
            collenv, collenr = int32
            if collenv == -1
              s += annotate(collenr, "null column value")
            else
              _, colvaluer = str(collenv)
              s += annotate(collenr, "#{collenv} bytes", colvaluer, "column value")
            end
          end
          "DataRow"

        when "E"
          loop do
            s += line_break
            errfieldv, errfieldr = char
            if errfieldv == bin_str("\x00")
              s += annotate(errfieldr, "end")
              break
            end
            err_field_name = {
              S: "severity",
              V: "unlocalized severity",
              C: "SQLSTATE code",
              M: "message",
              D: "detail",
              H: "hint",
              P: "position",
              p: "internal position",
              q: "internal query",
              W: "where",
              s: "schema",
              t: "table",
              c: "column",
              d: "data type",
              n: "constraint",
              F: "file",
              L: "line",
              R: "routine"
            }[errfieldv.to_sym]
            _, valuer = cstr
            s += annotate(errfieldr, "#{err_field_name}", valuer, "value")
          end
          "ErrorResponse"

        when "G", "H", "W"
          formatv, formatr, colcountv, colcountr = int8 + int16
          s += annotate(formatr, "copy format: #{text_or_binary(formatv)}", colcountr, "#{colcountv} column formats follow")
          colcountv.times do
            colformatv, colformatr = int16
            s += annotate(colformatr, "column format: #{text_or_binary(colformatv)}")
          end
          { G: "CopyInResponse", H: "CopyOutResponse", W: "CopyBothResponse" }[type_value.to_sym]

        when "I"; "EmptyQueryResponse"

        when "K"
          _, pidr, _, secretkeyr = int32 + int32
          s += annotate(pidr, "process ID", secretkeyr, "secret key")
          "BackendKeyData"

        when "N"; "NoticeResponse"

        when "R"
          authtypev, authtyper = int32
          @@prev_auth_type = authtypev
          auth_msg_name = case authtypev
          when 0; "AuthenticationOk"
          when 2; "AuthenticationKerberosV5"
          when 3; "AuthenticationCleartextPassword"
          when 7; "AuthenticationGSS"
          when 8; "AuthenticationGSSContinue"
          when 9; "AuthenticationSSPI"

          when 5
            _, saltr = bytes(4)
            s += annotate(saltr, "MD5 salt")
            "AuthenticationMD5Password"

          when 10
            begin
              s += line_break
              mechv, mechr = cstr
              s += annotate(mechr, mechv.empty? ? "end" : "SASL mechanism")
            end until mechv.empty?
            "AuthenticationSASL"

          when 11
            _, scramdatar = str(lenv - 8)
            s += line_break + annotate(scramdatar, "SCRAM server-first-message")
            "AuthenticationSASLContinue"

          when 12
            _, scramdatar = str(lenv - 8)
            s += line_break + annotate(scramdatar, "SCRAM server-final-message")
            "AuthenticationSASLFinal"

          else
            "unknown auth message type"
          end
          s = annotate(authtyper, auth_msg_name) + s
          "Authentication"

        when "S"
          _, keyr, _, valuer = cstr + cstr
          s += annotate(keyr, "key", valuer, "value")
          "ParameterStatus"

        when "T"
          colcountv, colcountr = int16
          s += annotate(colcountr, "#{colcountv} columns follow")
          colcountv.times do
            _, namer = cstr
            taboidv, taboidr, tabattrnumv, tabattrnumr = int32 + int16
            s += line_break + annotate(
              namer, "column name",
              taboidr, "table OID: #{taboidv}",
              tabattrnumr, "table attrib no: #{tabattrnumv}"
            )
            typoidv, typoidr, typlenv, typlenr, typmodv, typmodr = int32 + int16 + int32
            formatv, formatr = int16
            s += line_break + annotate(
              typoidr, "type OID: #{typoidv}",
              typlenr, "type length: #{typlenv}",
              typmodr, "type modifier: #{typmodv}",
              formatr, "format: #{text_or_binary(formatv)}"
            )
          end
          "RowDescription"

        when "V"
          valuelenv, valuelenr = int32
          if valuelenv == -1
            s += annotate(valuelenr, "null value")
          else
            s += annotate(valuelenr, "#{valuelenv} bytes follow")
            _, valuer = str(valuelenv)
            s += annotate(valuer, "value")
          end
          "FunctionCallResponse"

        when "Z"
          statusv, statusr = char
          status = { I: "idle", T: "in transaction block", E: "in failed transaction block" }[statusv.to_sym] || "unknown status"
          s += annotate(statusr, status)
          "ReadyForQuery"

        when "c"; "CopyDone"
        when "d"; "CopyData"
        when "n"; "NoData"
        when "s"; "PortalSuspended"

        when "t"
          paramcountv, paramcountr = int16
          s += annotate(paramcountr, "number of parameters")
          paramcountv.times do
            paramoidv, paramoidr = int32
            s += annotate(paramoidr, "parameter type OID: #{paramoidv}")
          end
          "ParameterDescription"

        when "v"
          protov, protor = int32
          s += annotate(protor, "newest minor protocol version supported: #{protov}")
          optioncountv, optioncountr = int32
          s += annotate(optioncountr, "number of unrecognised protocol options: #{optioncountv}")
          optioncountv.times do
            _, optionr = cstr
            s += line_break + annotate(optionr, "unrecognised option")
          end
          "NegotiateProtocolVersion"

        else; "unknown server message"
        end

      elsif @source == :client
        case type_value
        when "B"
          _, portalr, _, statementr = cstr + cstr
          s += annotate(portalr, "destination portal", statementr, "source prepared statement")
          code_count, r = int16
          s += line_break + annotate(r, "#{code_count} parameter format codes follow")
          code_count.times do
            v, r = int16
            s += annotate(r, "format: #{text_or_binary(v)}")
          end
          paramcountv, paramcountr = int16
          s += line_break + annotate(paramcountr, "#{paramcountv} parameter values follow")
          paramcountv.times do
            paramlenv, paramlenr = int32
            if paramlenv == -1
              s += annotate(paramlenr, "null")
            else
              s += annotate(paramlenr, "#{paramlenv} bytes follow")
              _, paramr = str(paramlenv)
              s += annotate(paramr, "parameter value")
            end
          end
          resultcountv, resultcountr = int16
          s += line_break + annotate(resultcountr, "#{resultcountv} result format codes follow")
          resultcountv.times do
            formatv, formatr = int16
            s += annotate(formatr, "format: #{text_or_binary(formatv)}")
          end
          "Bind"

        when "C", "D"
          thingtypev, thingtyper, _, thingnamer = char + cstr
          thingtype = thingtypev == "S" ? "prepared statement" : thingtypev == "P" ? "portal" : "unknown"
          s += annotate(thingtyper, thingtype, thingnamer, "name of #{thingtype}")
          { C: "Close", D: "Describe" }[type_value.to_sym]

        when "E"
          _, pnr, maxv, maxr = cstr + int32
          s += annotate(pnr, "portal name", maxr, "max rows: #{maxv}" + (maxv == 0 ? " = no limit" : ""))
          "Execute"

        when "F"
          fnoidv, fnoidr = int32
          s += annotate(fnoidr, "function OID: #{fnoidv}")
          formatcountv, formatcountr = int16
          s += line_break + annotate(formatcountr, "#{formatcountv} format codes follow")
          formatcountv.times do
            formatv, formatr = int16
            s += annotate(formatr, "format: #{text_or_binary(formatv)}")
          end
          argscountv, argscountr = int16
          s += line_break + annotate(argscountr, "#{argscountv} arguments follow")
          argscountv.times do
            arglenv, arglenr = int32
            _, argvalr = str(arglenv)
            s += annotate(arglenr, "#{arglenv} bytes", argvalr, "argument")
          end
          formatv, formatr = int16
          s += line_break + annotate(formatr, "result format: #{text_or_binary(formatv)}")
          "FunctionCall"

        when "H"; "Flush"

        when "P"
          _, dr, _, qr = cstr + cstr
          s += annotate(dr, "destination prepared statement", qr, "SQL query")
          pdt_count, r = int16
          s += annotate(r, "#{pdt_count} parameter data types follow")
          pdt_count.times do
            v, r = int32
            s += annotate(r, "parameter type OID: #{v}")
          end
          "Parse"

        when "Q"
          _, queryr = cstr
          s += annotate(queryr, "query")
          "Query"

        when "S"; "Sync"
        when "X"; "Terminate"
        when "c"; "CopyDone"
        when "d"; "CopyData"

        when "f"
          _, errmsgr = cstr
          s += annotate(errmsgr, "error message")
          "CopyFail"

        when "p"
          # p can mean various things depending on context, so we need to check the last message sent the other way
          case @@prev_auth_type
          when 3 # AuthenticationCleartextPassword
            _, pwdr = cstr
            s += annotate(REDACT ? "[redacted]" : pwdr, "password")
            "PasswordMessage (cleartext)"

          when 5 # AuthenticationMD5Password
            _, md5r = cstr
            s += annotate(REDACT ? "[redacted]" : md5r, "'md5' + md5(md5(pwd + user) + salt)")
            "PasswordMessage (MD5)"

          when 10 # AuthenticationSASL
            _, mechr  = cstr
            s += line_break + annotate(mechr, "selected mechanism")
            scramlenv, scramlenr = int32
            s += line_break + annotate(scramlenr, "#{scramlenv} bytes follow")
            _, scramdata = str(scramlenv)
            s += line_break + annotate(scramdata, "SCRAM client-first-message")
            "SASLInitialResponse"

          when 11 # AuthenticationSASLContinue
            _, scramdata = str(lenv - 4)
            s += line_break + annotate(scramdata, "SCRAM client-final-message")
            "SASLResponse"

          else
            "PasswordMessage/SASLInitialResponse/SASLResponse/GSSResponse"
          end

        else
          "unknown client message"
        end

      else
        raise "unknown message source #{@source}"
      end

      s = annotate(type_repr, type_name, lenr, "#{lenv} bytes") + s # prefix the message name and length
    end

    s += annotate(@msg[@i..].inspect, "data") if @msg.length > @i # log any so-far unparsed data
    s
  end
end

# Postgres writes

def pg_msg(type, msg)
  bin_str(type + [msg.length + 4].pack("N") + msg)
end

def pg_send(sock, rawmsgs, source = nil)
  rawmsgs.each { |msg| yield PgMessage.new(msg, source).inspect } if block_given?
  bytes = rawmsgs.join
  if BYTE_WRITE
    bytes.each_char { |char| sock.write(char) }
  else
    sock.write(bytes)
  end
  bytes.length
end

# Postgres reads

class BufferingConnection
  attr_reader :buffer

  def initialize(sock)
    super()
    @sock = sock
    @buffer = bin_str("")
  end

  def blocking_buffer_to(length)
    if @buffer.length < length
      bytes = @sock.read(length - @buffer.length)
      return nil if bytes.nil?
      @buffer += bytes
    end
    true
  end

  def nonblocking_buffer_to(length)
    return true if @buffer.length >= length
    begin
      bytes = @sock.read_nonblock((1 << 31) - 1) # maximum possible read
      @buffer += bytes
      @buffer.length >= length # return true or false
    rescue OpenSSL::SSL::SSLErrorWaitReadable, OpenSSL::SSL::SSLErrorWaitWritable, IO::EAGAINWaitReadable
      false
    rescue OpenSSL::SSL::SSLError, EOFError
      nil
    end
  end

  def buffer_to(length, blocking)
    blocking ? blocking_buffer_to(length) : nonblocking_buffer_to(length)
  end
end

class PGConnection < BufferingConnection
  def initialize(sock, source)
    super(sock)
    @source = source # :server, :client, :startup or nil
  end

  def next_message(blocking = true)
    # if blocking: returns message, or nil at EOF
    # if non-blocking: returns message, or false if none available, or nil at EOF
    result = buffer_to(5, blocking) or return result
    length_incl = @buffer[1...5].unpack1("N")
    result = buffer_to(1 + length_incl, blocking) or return result # 1 + not 5 +, because len is inclusive
    msg = @buffer.slice!(0..length_incl) # inclusive length accounts for the first (message type) byte
    yield PgMessage.new(msg, @source).inspect if block_given?
    msg
  end

  def available_messages(&blk)
    messages = []
    while true do
      nm = next_message(messages.empty?, &blk)
      return nil if nm.nil? && messages.empty?
      break unless nm
      messages << nm
    end
    messages
  end
end

# tls-server-end-point channel-binding support for ScramSHA256Authenticator net/imap

if has_sasl
  class ScramSHA256Authenticator < Net::IMAP::SASL::ScramSHA256Authenticator
    def initialize(*args, **options)
      super(*args, **options)
      @ssl_cert = options[:ssl_cert]
    end

    def gs2_cb_flag
      @ssl_cert.nil? ? "n" : "y" # y => would have supported -PLUS if server had offered it
    end
  end

  class ScramSHA256PlusAuthenticator < ScramSHA256Authenticator
    def gs2_cb_flag
      "p=tls-server-end-point"
    end

    def cbind_input
      cert_algo_raw = @ssl_cert.signature_algorithm
      cert_algo = OpenSSL::Digest.new(cert_algo_raw).name # standardize e.g. sha256WithRSAEncryption -> SHA256
      sasl_algo = cert_algo == "MD5" || cert_algo == "SHA1" ? "SHA256" : cert_algo
      hash = OpenSSL::Digest.digest(sasl_algo, @ssl_cert.to_der)
      "#{gs2_header}#{hash}"
    end
  end
end

# certificate generation

def make_key_and_cert(subject, sig)
  key = sig == "ecdsa" ? OpenSSL::PKey::EC.generate("prime256v1") : OpenSSL::PKey::RSA.new(2048)
  public_key = sig == "ecdsa" ? OpenSSL::PKey::EC.new(key.public_to_pem) : key.public_key

  cert = OpenSSL::X509::Certificate.new
  cert.public_key = public_key
  cert.not_before = Time.now - 24 * 3600 # 24 hours ago
  cert.not_after = Time.now + 48 * 3600 # 48 hours ahead

  # for sslmode=require, the server cert can be _extremely_ bare bones: the following are not required
  cert.version = 2 # cf. RFC 5280 - to make it a "v3" certificate
  cert.serial = (1 + SecureRandom.random_number((1 << 128) - 1)).to_bn # not zero
  cert.issuer = cert.subject = OpenSSL::X509::Name.parse(subject)

  cert.sign(key, "SHA256")
  [key, cert]
end

# main loop

ssl_request = [8, (1234 << 16) + 5679].pack("NN")

class ClientEOFException < StandardError; end
class ServerEOFException < StandardError; end

server = TCPServer.new("0.0.0.0", options[:listen_port])

loop do
  begin
    puts "listening ..."
    target_via_sni = nil
    client_sock = server.accept
    puts "connected at t0 = #{Time.now}"
    t0 = t_now

    # client SSL context

    client_ctx = OpenSSL::SSL::SSLContext.new

    if options[:ssl_key] && options[:ssl_cert]
      client_ctx.key = OpenSSL::PKey::RSA.new(File.open(options[:ssl_key]))
      client_ctx.cert = OpenSSL::X509::Certificate.new(File.open(options[:ssl_cert]))
    else
      raise "must specify both or neither of --ssl-cert and --ssl-key" if options[:ssl_key] || options[:ssl_cert]
      client_ctx.key, client_ctx.cert = make_key_and_cert("CN=#{SCRIPT_NAME}", options[:cert_sig])
    end

    client_ctx.servername_cb = lambda do |sniData|
      sni_sock, sni_name = sniData
      target_via_sni = sni_name
      sni_sock.context
    end

    client_ctx.alpn_select_cb = lambda do |protocols|
      # alpn is required in response for direct SSL connections
      raise "unexpected ALPN protocols: #{protocols.inspect}" unless protocols == ["postgresql"]
      protocols.first
    end

    unless options[:client_sslkeylogfile].nil?
      client_ctx.keylog_cb = proc do |_sock, line|
        File.open(options[:client_sslkeylogfile], "a") { |f| f.puts(line) }
      end
    end

    # SSL negotiations

    client_direct_ssl = nil

    first_byte = client_sock.recv(1, Socket::MSG_PEEK)
    next if first_byte.nil?

    if first_byte == bin_str("\x16") # start of a TLS handshake record
      client_direct_ssl = true
      client_sock = OpenSSL::SSL::SSLSocket.new(client_sock, client_ctx).accept # begin handshake
      puts "direct #{tls_summary(client_sock)} connection established with client", "  server name via SNI: #{target_via_sni}"

      first_eight = client_sock.read(8)

    else
      # not direct SSL, so we may or may not begin with an 8-byte SSLRequest
      first_eight = client_sock.read(8)

      if first_eight == ssl_request
        client_direct_ssl = false
        puts client_to_script(annotate(hex_inspect(first_eight), "SSLRequest"))

        if options[:deny_ssl]
          client_sock.write("N")
          puts script_to_client(annotate("N".inspect, "SSL not supported"))

        else
          client_sock.write("S")
          puts script_to_client(annotate("S".inspect, "SSL supported"))

          client_sock = OpenSSL::SSL::SSLSocket.new(client_sock, client_ctx).accept # begin handshake
          puts "#{tls_summary(client_sock)} connection established with client", "  server name via SNI: #{target_via_sni}"
        end

        first_eight = client_sock.read(8)

      else
        puts "no SSLRequest: continuing in plaintext"
      end
    end

    puts client_sock.cert.to_text, client_sock.cert.to_pem if options[:log_certs] && client_sock.respond_to?(:cert)

    next if first_eight.nil? # start again if disconnected

    # connection startup + auth

    len = first_eight[0..3].unpack1("N")
    startup_msg = client_sock.read(len - 8)
    full_startup = first_eight + startup_msg
    puts client_to_script(PgMessage.new(full_startup, :startup).inspect)

    username = nil
    startup_msg.split("\x00").each_slice(2) { |x| username = x[1] if x[0] == "user" }

    server_name = options[:target] || (target_via_sni ? target_via_sni.chomp(options[:delete_host_suffix]) : "localhost")

    puts "connecting to Postgres server: #{server_name}"

    server_sock = TCPSocket.new(server_name, options[:connect_port])

    if options[:sslmode] != 'disabled'
      server_direct_ssl = options[:ssl_negotiation] == "direct" || (options[:ssl_negotiation] == "mimic" && client_direct_ssl)

      unless server_direct_ssl
        server_sock.write(ssl_request)
        puts script_to_server(annotate(hex_inspect(ssl_request), "SSLRequest"))

        server_speaks_ssl = server_sock.read(1)
        puts server_to_script(annotate(server_speaks_ssl.inspect, server_speaks_ssl == "S" ? "SSL supported" : "SSL not supported"))
      end

      if server_speaks_ssl == "S" || server_direct_ssl
        server_ctx = OpenSSL::SSL::SSLContext.new
        server_ctx.alpn_protocols = ['postgresql']  # required for direct connections

        server_ctx.verify_mode = options[:sslmode].start_with?('verify') ? OpenSSL::SSL::VERIFY_PEER : OpenSSL::SSL::VERIFY_NONE
        server_ctx.verify_hostname = options[:sslmode] == 'verify-full'

        server_ctx.cert_store = OpenSSL::X509::Store.new
        unless options[:sslrootcert].nil?
          if options[:sslrootcert] == 'system'
            server_ctx.cert_store.set_default_paths
          elsif File.directory?(options[:sslrootcert])
            server_ctx.cert_store.add_path(options[:sslrootcert])
          else
            server_ctx.cert_store.add_file(options[:sslrootcert])
          end
        end

        unless options[:server_sslkeylogfile].nil?
          server_ctx.keylog_cb = proc do |_, line|
            File.open(options[:server_sslkeylogfile], "a") { |f| f.puts(line) }
          end
        end

        server_sock = OpenSSL::SSL::SSLSocket.new(server_sock, server_ctx)
        server_sock.hostname = server_name
        server_sock.connect

        puts "#{server_direct_ssl ? "direct " : ""}#{tls_summary(server_sock)} connection established with server"
        puts server_sock.peer_cert.to_text, server_sock.peer_cert.to_pem if options[:log_certs]

      elsif server_speaks_ssl == "N"
        raise 'server does not support SSL' if options[:connect_sslmode] != 'prefer'
        puts "continuing without encryption"

      else
        raise "expected S or N in response to SSLRequest, but got #{server_speaks_ssl.inspect}"
      end
    end

    puts "forwarding client startup message to server"
    server_sock.write(full_startup)
    puts script_to_server(PgMessage.new(full_startup, :startup).inspect)

    server_reader = PGConnection.new(server_sock, :server)
    client_reader = PGConnection.new(client_sock, :client)

    # authentication override, if requested

    if options[:force_password] # request password from client, and use it to do either password or SCRAM auth with server
      puts "now overriding authentication"
      auth_msg = server_reader.next_message { |str| puts server_to_script(str) }
      next if auth_msg.nil?
      raise "expected auth message" unless auth_msg[0] == "R"

      auth_type = auth_msg[5..8].unpack1("N")
      if auth_type == 0
        puts "forwarding AuthenticationOk message to client"
        pg_send(client_sock, [auth_msg], :server) { |str| puts script_to_client(str) }

      else
        # request cleartext password from client
        pg_send(client_sock, [pg_msg("R", "\x00\x00\x00\x03")], :server) { |str| puts script_to_client(str) }
        pwd_msg = client_reader.next_message(true) { |str| puts client_to_script(str) }
        next if pwd_msg.nil? # restart on disconnect: this happens if psql prompts the user for the password
        raise "expected password message" unless pwd_msg[0] == "p"
        pwd = pwd_msg[5..].unpack1("Z*") # remove null terminator

        # silently re-parse the auth message so as to keep track of the auth protocol stage we're at with the server
        PgMessage.new(auth_msg, :server).inspect

        case auth_type
        when 3 # AuthenticationCleartextPassword -> forward the client's message on
          pg_send(server_sock, [pwd_msg], :client) { |str| puts script_to_server(str) }

        when 5 # AuthenticationMD5
          salt = auth_msg[9..]
          md5 = Digest::MD5.hexdigest(Digest::MD5.hexdigest(pwd + username) + salt)
          pg_send(server_sock, [pg_msg("p", "md5#{md5}\x00")], :client) { |str| puts script_to_server(str) }

        when 10 # AuthenticationSASL
          unless has_sasl
            puts "SCRAM auth was requested by server but is not supported on this version of Ruby: exiting"
            exit 1
          end
          authenticators = { # highest preference first
            **(options[:channel_binding] ? {"SCRAM-SHA-256-PLUS" => ScramSHA256PlusAuthenticator} : {}),
            "SCRAM-SHA-256" => ScramSHA256Authenticator,
          }
          offered_mechanisms = auth_msg[9..].split("\x00")
          mechanism = (authenticators.keys & offered_mechanisms).first
          raise "no supported SASL mechanism: support #{authenticators.keys.inspect}, offered #{offered_mechanisms.inspect}" if mechanism.nil?

          auth = authenticators[mechanism].new(username: "*", password: pwd, ssl_cert: options[:channel_binding] ? server_sock.peer_cert : nil)
          client_initial_msg = auth.process(nil)
          scram_msg = bin_str("#{mechanism}\x00#{[client_initial_msg.length].pack("N")}#{client_initial_msg}")
          pg_send(server_sock, [pg_msg("p", scram_msg)], :client) { |str| puts script_to_server(str) }

          server_first_msg = server_reader.next_message { |str| puts server_to_script(str) }
          next if server_first_msg.nil?
          raise "expected AuthenticationSASLContinue" unless server_first_msg[0] == "R" && server_first_msg[5..8] == bin_str("\x00\x00\x00\x0b")

          client_final_msg = auth.process(server_first_msg[9..])
          pg_send(server_sock, [pg_msg("p", client_final_msg)], :client) { |str| puts script_to_server(str) }

          server_final_message = server_reader.next_message { |str| puts server_to_script(str) }
          next if server_final_message.nil?
          raise "expected AuthenticationSASLFinal" unless server_final_message[0] == "R" && server_final_message[5..8] == bin_str("\x00\x00\x00\x0c")

          auth.process(server_final_message[9..]) # raises an error if server is not authenticated

        else
          raise "unsupported server auth type with code: #{auth_type}"
        end
      end
    end

    # proxy ongoing traffic

    log_proxied = options[:log_proxied] != "none"
    puts "#{log_proxied ? "" : "silently "}forwarding all later traffic"

    # pass messages from server to client
    thread = Thread.new do
      while true do
        messages = server_reader.available_messages { |str| puts server_to_client(str) if log_proxied }
        raise ServerEOFException.new if messages.nil?
        bytes_sent = pg_send(client_sock, messages)
        puts "^^ #{bytes_sent} bytes forwarded #{BYTE_WRITE ? 'one by one ' : ''}at +#{(t_now - t0).floor(2)}s, #{server_reader.buffer.length} bytes left in buffer" if log_proxied
      end
    end
    thread.abort_on_exception = true

    # pass messages from client to server
    while true do
      messages = client_reader.available_messages { |str| puts client_to_server(str) if log_proxied }
      raise ClientEOFException.new if messages.nil?
      bytes_sent = pg_send(server_sock, messages)
      puts "^^ #{bytes_sent} bytes forwarded #{BYTE_WRITE ? 'one by one ' : ''}at +#{(t_now - t0).floor(2)}s, #{client_reader.buffer.length} bytes left in buffer" if log_proxied
    end

  rescue ServerEOFException
    puts "server hung up"

  rescue ClientEOFException
    puts "client hung up"

  ensure
    puts "connection end", ""
    client_sock.close unless client_sock.nil?
    #server.close unless server.nil?
    thread.kill unless thread.nil?

    exit if options[:quit_on_hangup]
  end
end
